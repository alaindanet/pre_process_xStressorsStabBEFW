---
title: "Target Markdown"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Target Markdown is a powerful R Markdown interface for reproducible analysis
pipelines, and the chapter at https://books.ropensci.org/targets/markdown.html
walks through it in detail. This R Markdown report the example from the chapter.
Try it out in both interactive and non-interactive modes, either by running the
code chunks in different ways or setting the `tar_interactive` chunk option.

# Packages

The example requires several R packages, and `targets` must be version 0.5.0.9000 or above.

```{r, eval = FALSE}
install.packages(c("biglm", "dplyr", "ggplot2", "readr", "targets", "tidyr"))
```

# Setup

If you are using old versions of `targets` (<= 0.7.0) and/or `knitr` (<= 1.33), you will need to load the `targets` package in the R Markdown document in order for Target Markdown code chunks to work.


Near the top of the document, you may also wish to remove the `_targets_r` directory previously written by non-interactive runs of the report. Otherwise, your pipeline may contain superfluous targets.

```{r}
library(targets)
library(tarchetypes)
tar_unscript()
```

# Globals

We first define some global options/functions common to all targets. The function below plots a histogram of ozone concentrations, and our histogram target will need it.

```{targets example-globals, tar_globals = TRUE}
options(tidyverse.quiet = TRUE)
tar_config_set(store = "/mnt/parscratch/users/bi1ahd/pre_process_xStressorsStabBEFW_targets/")
tar_option_set(
  packages = c("tarchetypes", "tidyverse", "magrittr", "cowplot", "here", "arrow", "piecewiseSEM", "semEff", "easystats", "glmmTMB", "ggcorrplot", "kableExtra"),
  error = "null"
  )
dir_fun <- "~/xStressorsStabBEFW/"
source(paste0(dir_fun, "R/network_metrics.R"))
source(paste0(dir_fun, "R/string_replacements.R"))
source(paste0(dir_fun, "R/stability_decomposition.R"))
source(paste0(dir_fun, "R/model_helpers.R"))
source(paste0(dir_fun, "R/sem_helpers.R"))
compute_metabolic_loss <- function(Z = NULL, tlvl = NULL, ax = .88, bx = -0.25) {
  M = Z ^ (tlvl - 1)
  x = ax*M^(bx)
  x[tlvl == 1] <- 0
  x
}
source(here::here("R", "data_prep.R"))
source(here::here("R", "model_helpers.R"))

#Â Necessary for tar_map()
sim_to_map <- tibble::tibble(
    dir_name = c("simCSh_allo_d5/", "simCSh_allo_d5_no_rerun/",
      "simCSh_non_allo_d5_no_rerun/"),
    name = c("rerun", "no_rerun", "non_allo_no_rerun"),
    full_path = paste0("/mnt/parscratch/users/bi1ahd/sim/", dir_name)
    )
```

```{r, eval =FALSE}
sim_to_map <- tibble::tibble(
    dir_name = c("simCSh_allo_d5/", "simCSh_allo_d5_no_rerun/",
      "simCSh_non_allo_d5_no_rerun/"),
    name = c("rerun", "no_rerun", "non_allo_no_rerun"),
    full_path = paste0("/mnt/parscratch/users/bi1ahd/sim/", dir_name)
    )
```


# Targets



## Sim with metabolic death

```{targets raw_sim}
list(
  tar_target(sim_dir, "/mnt/parscratch/users/bi1ahd/sim/simCSh/"),
  tar_target(var_param_sim, c("fw_id", "productivity", "rho", "env_stoch", "Z", "h")),
  tar_target(pre_sim_files_no_ts, list.files(paste0(sim_dir, "without_cvsp/"))),
  tar_target(sim_iteration_no_ts,
    as.numeric(str_extract(pre_sim_files_no_ts, "simCSh_(\\d+)_", group = 1))
    ),
  tar_target(sim_files_no_ts2, pre_sim_files_no_ts[order(sim_iteration_no_ts)]),
  tar_target(pre_sim_files_ts,
    list.files(sim_dir) %>% #
      .[str_detect(., "_ts")]
    ),
  tar_target(sim_iteration_ts,
    as.numeric(str_extract(pre_sim_files_ts, "simCSh_(\\d+)_", group = 1))
    ),
  tar_target(sim_files_ts2, pre_sim_files_ts[order(sim_iteration_ts)]),
  tar_target(sim_param,
    open_dataset("~/xStressorsStabBEFW/scripts/param_comb_ct_S_h.arrow",
      format = "arrow") %>%
    collect() %>%
    rename(productivity = K, env_stoch = sigma)
    ),
  tar_target(sim_prep,
        open_dataset(paste0(sim_dir, "without_cvsp/", sim_files_no_ts2),
          format = "arrow") %>%
        collect() %>%
        # Transform back interaction strength into matrices
        mutate(across(where(is.list), as.list)) %>%
        filter(!is.na(richness)) %>%
        mutate(across(c(int_strength, max_int),
            ~map2(.x, S,
              function(y, rich) {
                matrix(y, nrow = rich)
              }
            )
          )
          ) %>%
        # Get matrix of alive species
        mutate(max_int_alive  = map2(max_int, bm_sp,
            function(mat, bm) {
              mask <- bm > 10^-6
              mat[mask, mask, drop = FALSE]
            }
          )
        ) %>%
        select(-max_int),
        pattern = sim_files_no_ts2
      ),
  tar_target(sim_net,
    sim_prep %>%
      mutate(
        persistence = richness / S,
        async = 1 / sync,
        stab_pop = 1 / avg_cv_sp,
        ct_alive = map_dbl(max_int_alive,
          ~ifelse(sum(.x) == 0, 0,
            sum(.x > 0) / ((ncol(.x))^2))),
        max_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) == 0, 0, max(.x[.x > 0]))
          ),
        avg_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) == 0, 0, mean(.x[.x > 0]))
          ),
        sd_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) <= 1, 0, sd(.x[.x > 0]))
          ),
        cv_max_int_alive = sd_max_int_alive / avg_max_int_alive,
        inv_sd_max_int_alive = 1 / sd_max_int_alive,
        gini_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) == 0, 0, gini(.x[.x > 0]))),
        avg_omnivory = map_dbl(omnivory, mean),
        disconnected_prod = map_lgl(max_int_alive,
          ~any(colSums(.x) == 0 & rowSums(.x) == 0))
        ) %>%
    select(!where(is.list))
  ),
  tar_target(sim_ts2_null,
    open_dataset(paste0(sim_dir, sim_files_ts2),
          format = "arrow") %>%
        collect() %>%
        # Transform back interaction strength into matrices
        mutate(across(where(is.list), as.list)) %>%
        mutate(is_null = map_lgl(species, is.null)) %>%
        select(is_null),
        pattern = sim_files_ts2
        ),
  tar_target(sim_ts_mat,
    open_dataset(paste0(sim_dir, sim_files_ts2), format = "arrow") %>%
        collect() %>%
        # Transform back interaction strength into matrices
        mutate(across(where(is.list), as.list)) %>%
        filter(!map_lgl(species, is.null)) %>%
        mutate(
          species = map(species, ~matrix(.x, nrow = 100)),
          stoch = map(stoch, ~matrix(.x, nrow = 100))
          ),
    pattern = sim_files_ts2
  ),
  tar_target(sim_ts_mat_param,
    cbind(
      sim_param[!sim_ts2_null$is_null,] %>% select(-A),
      sim_ts_mat
      ) %>%
    as_tibble()
  ),
  tar_target(sim_ts2,
    open_dataset(paste0(sim_dir, sim_files_ts2),
          format = "arrow") %>%
        collect() %>%
        # Transform back interaction strength into matrices
        mutate(across(where(is.list), as.list)) %>%
        filter(!map_lgl(species, is.null)) %>%
        mutate(
          stoch_d = map2(species, stoch, function(bm, d_stoch) {
            .1 * bm * exp(d_stoch)
            }),
          species = map(species, ~matrix(.x, nrow = 100)),
          stoch = map(stoch, ~matrix(.x, nrow = 100)),
          stoch_d = map(stoch_d, ~matrix(.x, nrow = 100)),
          cpe = map_dbl(species, compensatory_effect),
          cpe_env = map_dbl(stoch_d, compensatory_effect),
          cpe_int = cpe / cpe_env,
          stab_com = map_dbl(species, community_stability),
          pop_stab = map_dbl(species, population_stability),
          bm_sp = map(species, ~colMeans(.x)),
          bm_total = map_dbl(bm_sp, ~sum(.x)),
          sd_sp = map(species, ~apply(.x, 2, sd)),
          sum_sd_sp = map_dbl(sd_sp, ~sum(.x)),
          async = map_dbl(species, asynchrony),
          sae = map(species, statistical_averaging_effect),
          sae_total = map_dbl(sae, ~.x["total"]),
          sae_even = map_dbl(sae, ~.x["even"]),
          evenness_sae = map_dbl(sae, ~.x["eveness"])
        ) %>%
        select(-species, -stoch_d, -stoch),
        pattern = sim_files_ts2
  )
  )
```

```{targets stab_consumer, tar_simple = TRUE}
sim_prep %>%
  select(all_of(c(var_param_sim, "alive_species", "tlvl", "max_tlvl"))) %>%
  left_join(sim_ts_mat_param) %>%
  filter(!is.na(S), max_tlvl > 1) %>%
  mutate(
    met_loss = map2(Z, tlvl, ~compute_metabolic_loss(Z = .x, tlvl = .y, ax = .88, bx = -0.25)),
    met_loss = map2(met_loss, tlvl, ~.x[.y > 1]),
    species = map2(species, alive_species, ~.x[, .y, drop = FALSE]),
    species = map2(species, tlvl, ~.x[, .y > 1, drop = FALSE]),
    stoch = map2(stoch, alive_species, ~.x[, .y, drop = FALSE]),
    stoch = map2(stoch, tlvl, ~.x[, .y > 1, drop = FALSE]),
    stoch_d = pmap(list(bm = species, d_stoch = stoch, m = met_loss), function(bm, d_stoch, m) {
      bm %*% diag(m, nrow = length(m)) * exp(d_stoch)
      }),
    cpe = map_dbl(species, compensatory_effect),
    cpe_env = map_dbl(stoch_d, compensatory_effect),
    cpe_int = cpe / cpe_env,
    stab_com = map_dbl(species, community_stability),
    pop_stab = map_dbl(species, population_stability),
    bm_sp = map(species, ~colMeans(.x)),
    bm_total = map_dbl(bm_sp, ~sum(.x)),
    sd_sp = map(species, ~apply(.x, 2, sd)),
    sum_sd_sp = map_dbl(sd_sp, ~sum(.x)),
    async = map_dbl(species, asynchrony),
    sae = map(species, statistical_averaging_effect),
    sae_total = map_dbl(sae, ~.x["total"]),
    sae_even = map_dbl(sae, ~.x["even"]),
    evenness_sae = map_dbl(sae, ~.x["eveness"])
    ) %>%
  select(-sae, -stoch_d, - max_tlvl)
```

```{targets cons-stab-data}
list(
  tar_target(sim_cons,
    left_join(sim_net %>% select(-async, -stab_com), stab_consumer,
      by = c(var_param_sim, "S"))
    ),
  tar_target(sim_fw_cons,
    sim_cons %>%
      filter(
        max_tlvl > 1,
        sum_sd_sp != Inf,
        bm_total > 10^-5,
        !disconnected_prod
        ) %>%
    select(!where(is.list))
   ),
   tar_target(sim_fw_cons_df, as.data.frame(sim_fw_cons))
   )
```

## Species bm, sd and tlvl

```{targets sim_sp, tar_simple = TRUE, eval = FALSE}
sim_stab_d %>%
  select(all_of(c(var_param_sim, "sd_sp", "bm_sp"))) %>%
  left_join(
    sim_prep_d %>%
      select(all_of(c(var_param_sim_d, "tlvl", "alive_species")))
  ) %>%
  mutate(
    sd_sp = map2(sd_sp, alive_species, ~.x[.y]),
    bm_sp = map2(bm_sp, alive_species, ~.x[.y]),
    cv_sp = map2(sd_sp, bm_sp, ~.x / .y),
    tlvl_bm_sd_sp = pmap(list(tlvl, bm_sp, sd_sp, cv_sp, alive_species),
      function(x, y, z, a, b) {
        rbind.data.frame(list(
        species = b,
            tlvl = x,
            bm_sp = y,
            sd_sp = z,
            cv_sp = a
        )
        )
      }),
    check = map_lgl(tlvl_bm_sd_sp, ~is.null(nrow(.x)))
  ) %>%
  filter(!check) %>%
  select(all_of(c(var_param_sim, "tlvl_bm_sd_sp"))) %>%
  unnest(c(tlvl_bm_sd_sp))
```

```{r}

```


## Sim with allometric death

```{r, eval=FALSE}
#https://books.ropensci.org/targets/static.html#dynamic-within-static-branching 
random_seed_target <- tar_target(random_seed, seq_len(10))
targets <- tar_map(
  values = tibble(method_function = rlang::syms(c("method1", "method2"))),
  tar_target(
    analysis,
    method_function("NIH", seed = random_seed),
    pattern = map(random_seed)
  ),
  tar_target(
    summary,
    summarize_analysis(analysis),
    pattern = map(analysis)
  )
)
```

```{targets}
library(tarchetypes)
tar_map(
  values = sim_to_map,
  names = "name",
  tar_target(file_no_ts, get_no_ts_file(dir = full_path)),
  tar_target(file_ts, get_ts_file(dir = full_path)),
  tar_target(sim_prep,
    prep_sim_for_analysis(
      dir = full_path,
      file = file_no_ts,
      extinct_bm_threshold = extinction_threshold,
      param_var = var_param_sim_d,
      param_table = sim_param_d2
      ),
    pattern = file_no_ts
    ),
  tar_target(sim_ts_mat,
    make_ts_vector_to_matrices(
      dir = full_path,
      file = file_ts,
      ntimestep = 500),
    pattern = file_ts
  ),
  tar_target(sim_net, compute_network_metrics(sim = sim_prep)),
  tar_target(sim_ts_prep,
    filter_alive_species_ts_matrices(
      ts_mat = sim_ts_mat,
      prep_sim = sim_prep
    ),
    pattern = map(sim_ts_mat)
  ),
  tar_target(sim_stab,
    compute_stability_metrics_ts(sim_ts_prep = sim_ts_prep),
     pattern = map(sim_ts_prep)
  ),
  tar_target(sim, get_sim_dataset(
      sim_stab = sim_stab,
      sim_net = sim_net
    )),
  tar_target(sim_fw, filter_sim_fw(x = sim)),
  tar_target(sim_fw_sem, get_sem_dataset(x = sim_fw)),
  tar_target(sem_simplified_model_list,
    get_sem_simplified_model_list(sim_fw_sem = sim_fw_sem)),
  tar_target(sem_simplified, get_sem(model_list = sem_simplified_model_list) ),
  tar_target(sem_simplified_coeff, get_sem_coeff(sem = sem_simplified)),
  tar_target(sem_simplified_eff, 
    get_sem_tot_effect(
      sem = sem_simplified,
      sem_data = sim_fw_sem,
      bootstrap_nb = 10,
      nb_cores = min(future::availableCores(), 2),
      ci_type = "perc"
    )
  )
)
```
```{r, eval = FALSE}
tar_load(c(sim_fw_no_rerun, sim_fw_rerun, sim_non_allo_no_rerun))
tar_manifest() %>%
  filter(str_detect(name, "sim_ts_prep_no_rerun"))
```


```{targets sem}
library(tarchetypes)
tar_map(
  values = sim_to_map,
  names = "name",
  tar_target(sem_model_list,
    get_sem_model_list(sim_fw_sem = sim_fw_sem)
    ),
  tar_target(sem, get_sem(model_list = sem_model_list)),
  tar_target(sem_coeff, get_sem_coeff(sem = sem)) #,
#  tar_target(sem_eff,
#    get_sem_tot_effect(
#      sem = sem,
#      sem_data = sim_fw_sem, 
#      bootstrap_nb = 10,
#      nb_cores = future::availableCores(),
#      ci_type = "perc"
#    )
#  )
)
```

```{r, eval=FALSE}
library(tidyverse)
library(magrittr)
tar_load(c(sem_norerun, sim_fw_sem_norerun))
ti <- tar_manifest()
ti %>%
  filter(str_detect(name, "sem_")) %>%
  print(n = 40)
```
```{r, eval = FALSE}
library(semEff)
tar_load(c(
    sem_simplified_eff_non_allo_no_rerun,
    sem_simplified_eff_no_rerun,
    sem_simplified_eff_rerun
    ))

summary(sem_simplified_eff_non_allo_no_rerun)
summary(sem_simplified_eff_no_rerun)
summary(sem_simplified_eff_rerun)
```



```{targets prep-allo_sim}
list(
  tar_target(extinction_threshold, 0),
  tar_target(sim_dir_d, '/mnt/parscratch/users/bi1ahd/sim/simCSh_allo_d5/'),
  tar_target(var_param_sim_d, c("fw_id", "rho", "env_stoch", "Z", "h")),
  tar_target(sim_files_ts_d, get_ts_file(dir = sim_dir_d)),
  tar_target(sim_files_no_ts_d, get_no_ts_file(dir = sim_dir_d)),
  tar_target(sim_param_d2,
    prep_param_table(file = "~/xStressorsStabBEFW/scripts/param_comb_ct_S_h_d3.arrow")),
  tar_target(sim_prep_d,
    prep_sim_for_analysis(
      dir = sim_dir_d,
      file = sim_files_no_ts_d,
      extinct_bm_threshold = extinction_threshold,
      param_var = var_param_sim_d,
      param_table = sim_param_d2
      ),
    pattern = sim_files_no_ts_d
  ),
  tar_target(sim_ts_mat_d,
    make_ts_vector_to_matrices(
      dir = sim_dir_d,
      file = sim_files_ts_d,
      ntimestep = 500),
    pattern = sim_files_ts_d
  ),
  tar_target(sim_net_d, compute_network_metrics(sim = sim_prep_d)),
  tar_target(sim_ts_d_prep, sim_ts_prep_rerun),
 tar_target(sim_stab_d,
   compute_stability_metrics_ts(sim_ts_prep = sim_ts_d_prep)#,
    #pattern = map(sim_ts_d_prep)
 )
)
```

```{targets sim_for_plot}
list(
  tar_target(sim_prep_for_plot,
  sim_fw %>%
    filter(
      rho %in% c(0, .25, .75, 1),
      h %in% c(2, 3),
      env_stoch %in% c(.1, .3, .6),
      S %in% c(10, 20, 30, 40),
      Z %in% c(1, 10, 100)
      ) %>%
      select(sim_id) %>%
      left_join(sim_prep_d %>%
        select(sim_id, int_strength, tlvl)
      )
    ),
  tar_target(sim_for_plot,
   sim_ts_d_prep %>%
     filter(sim_id %in% sim_prep_for_plot$sim_id) %>%
     left_join(sim_prep_for_plot)
    )
  )
```

# Dataset

```{targets}
list(
  tar_target(sim, get_sim_dataset(
      sim_stab = sim_stab_d,
      sim_net = sim_net_d
    )),
  tar_target(sim_fw, filter_sim_fw(x = sim))
)
```

# SEM



```{targets sem-process}
list(
  tar_target(sim_fw_sem, get_sem_dataset(x = sim_fw)),
  tar_target(sem_model_list,
    get_sem_model_list(sim_fw_sem = sim_fw_sem)
    ),
  tar_target(sem, get_sem(model_list = sem_model_list)),
  tar_target(sem_coeff, get_sem_coeff(sem = sem)),
  tar_target(sem_eff,
    get_sem_tot_effect(
      sem = sem,
      sem_data = sim_fw_sem, 
      bootstrap_nb = 10,
      nb_cores = min(future::availableCores(), 4),
      ci_type = "perc"
    )
  )
)
```

```{targets simplified-sem2}
list(
  tar_target(sem_simplified_model_list,
    get_sem_simplified_model_list(sim_fw_sem = sim_fw_sem)),
  tar_target(sem_simplified, get_sem(model_list = sem_simplified_model_list) ),
  tar_target(sem_simplified_coeff, get_sem_coeff(sem = sem_simplified)),
  tar_target(sem_simplified_eff, 
    get_sem_tot_effect(
      sem = sem_simplified,
      sem_data = sim_fw_sem,
      bootstrap_nb = 10,
      nb_cores = min(future::availableCores(), 4),
      ci_type = "perc"
    )
  )
  )
```



# Make targets

```{r force-rerun, eval=FALSE}
#tar_invalidate(names = c(sim_dir_d,sim_files_ts_d,sim_files_no_ts_d,sim_prep_d, sim_ts_mat_d))
#tar_invalidate(names = c(sim_param_d2))
```


```{r tar_make}
ncpu <- future::availableCores()
if (ncpu > 1) {
  tar_make_future(workers = min(future::availableCores() - 1, 24))
  tar_make_future(workers = 5)
} else {
  tar_make()
}
```

The `targets` dependency graph helps your readers understand the steps of your pipeline at a high level.

```{r}
tar_visnetwork()
```

At this point, you can go back and run `{targets}` chunks in interactive mode without interfering with the code or data of the non-interactive pipeline.

# Output

```{r load-fun}
sapply(c("targets","tidyverse", "magrittr", "cowplot", "here", "arrow", "piecewiseSEM", "semEff", "easystats", "glmmTMB", "ggcorrplot", "kableExtra"), require, character.only = TRUE)
dir_fun <- "~/xStressorsStabBEFW/"
source(paste0(dir_fun, "R/network_metrics.R"))
source(paste0(dir_fun, "R/string_replacements.R"))
source(paste0(dir_fun, "R/stability_decomposition.R"))
source(paste0(dir_fun, "R/model_helpers.R"))
source(paste0(dir_fun, "R/sem_helpers.R"))
```

```{r, eval = FALSE}
tar_load(sim_fw)
map(c("rho", "h", "env_stoch", "S", "Z"), ~unique(sim_fw[[.x]]))
sim_prep_d %>%
  mutate(omega_alive = map2(omega, alive_species, ~.x[.y, .y, drop = FALSE]))
  select(omega)
sim_prep_d$omega[[1]][sim_prep_d$alive_species[[1]], sim_prep_d$alive_species[[1]]]

sim_fw %>%
  filter(
    rho %in% c(0, .25, .75, 1),
    h %in% c(2, 3),
    env_stoch %in% c(.1, .2, .3, .6),
    S %in% c(10, 30, 40),
    Z %in% c(1, 5, 10, 100)
  )
```

```{r check-failed-sim, eval=FALSE}
tar_load(c(sim_prep_d, sim_param_d2))
sim_param_missing <- sim_param_d2 %>%
  filter(!sim_id %in% sim_prep_d$sim_id)
sim_param_missing %>%
  filter(S == 20)
sim_param_missing %>%
  select(!where(is.list)) %>%
  summary
tar_load(sim)
sim %>%
  filter(max_tlvl <= 1) %>%
  select(!where(is.list)) %>%
  summary()
sim %>%
  filter(disconnected_prod) %>% 
  select(stab_com, everything())

sim %>%
  filter(!disconnected_prod) %>% 
  select(stab_com, everything())
```

```{r, eval=FALSE}
tar_load(c(sem, sim_fw_sem))
tar_load(sem_simplified_eff)

summary(sim_fw$stab_com)
tar_load(sim_prep_d)
tar_load(sim)
sim %>%
  filter(!disconnected_prod)
sim %>%
  filter(max_tlvl <= 1)
sim[sim$sim_id == 3, ]$

tar_load(sim_fw)
tar_load(sim)
tar_load(c(sim_files_ts_d, sim_files_no_ts_d))
tar_load(sim_param_d)
length(sim_files_ts_d) + length(sim_files_no_ts_d)

id_done <- as.integer(str_extract(sim_files_no_ts_d, "_d(\\d+)", group = 1))
id_to_do <- seq(1, 72000, 2000)
(id_to_do[!id_to_do %in% id_done] - 1) / 2000
```

```{r}
tar_load(sim_prep_d)
ti <- sim_prep_d$int_strength[[4265]][sim_prep_d$alive_species[[4265]], sim_prep_d$alive_species[[4265]], drop = FALSE]
mi <- sim_prep_d$bm_sp[[4265]]


bm <- c(1, 2, .5)
diag(bm)
(map(1:ncol(m), ~m[.x, ] / bm[.x]))

m / matrix(rep(bm, each = nrow(m)), ncol = 3)
rindlist

m / diag(bm)
bm
t(apply(m, 1, "/", bm))

summary(sim_fw$avg_omnivory)

get_mortality_biomass_dyn <- function(bm, stoch, d) {
  stopifnot(all.equal(length(d), ncol(stoch), ncol(bm)))
  stopifnot(all(is.matrix(bm), is.matrix(stoch)))
  bm %*% diag(d, nrow = length(d)) * exp(stoch)
}

m <- matrix(seq(1:9), ncol = 3)
bm <- c(.1, 1, 10)
stoch <- matrix(rep(1/bm, each = nrow(m)), ncol = 3)

get_mortality_biomass_dyn(bm = bm, stoch = stoch, m = m)
```




```{r}
tar_load(sim_prep)
length(sim_prep$tlvl[[1]])
sim_prep$alive_species[[1]]
tar_load(sim_ts_mat_param)
```
```{r}
# Test that matrix multiplication works as expected
x <- 1:3
y <- matrix(1:6, ncol = 3)
z <- 1/(y %*% diag(x))
y %*% diag(x)
y %*% diag(x) * z
```

```{r}
tar_load(sim_prep_d)
tar_load(sim_fw)
summary(sim_fw$avg_int_strength)
```



```{r}
tar_load(sim_fw)
sim_fw %>%
  group_by(Z, resp_div) %>%
  summarise(
    cpe_env = mean(cpe_env, na.rm = TRUE),
    cpe_int = mean(cpe_int, na.rm = TRUE),
    async = mean(async, na.rm = TRUE)
  )
tar_load(stab_consumer)
sim_fw_cons %>%
  group_by(resp_div) %>%
  summarise(
    cpe_env = mean(cpe_env, na.rm = TRUE),
    cpe_int = mean(cpe_int, na.rm = TRUE),
    async = mean(async, na.rm = TRUE)
  )
object.size(sim_fw_cons) * 10^-6
object.size(sim_fw) * 10^-6
tar_load(sim_fw_cons)
tar_load(sim)
tar_load(sim_files_ts)
tar_load(sim_param)
tar_load(sim_prep)
sim_prep %>%
  filter(max_tlvl > 1) %>%
  group_by(resp_div) %>%
  summarise(sync = mean(sync, na.rm = TRUE))
colnames(sim_fw)
cor(sim_fw$evenness_sae, sim_fw$resp_div, use = "pairwise.complete.obs")
```

```{r save-ts-sample}
dir_to_save <- "/mnt/parscratch/users/bi1ahd/pre_process_xStressorsStabBEFW_targets/objects/"
tar_load(sim_for_plot)
length(unique(sim_for_plot$sim_id))
nrow(sim_for_plot)
save(sim_for_plot, file = paste0(dir_to_save, "sim_for_plot"))
```


